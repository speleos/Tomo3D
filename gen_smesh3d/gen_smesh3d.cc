/*
 * gen_smesh3d.cc
 *
 * usage: gen_smesh3d [ options ]
 *
 * ZELT OPTIONS NOT AVAILABLE YET.
 *
 * <velocity setting options>
 *     [uniform gradient]
 *             -Av0 -Bgradient
 *     [1D/2D/3D velocity profile (to be hung from the seafloor]
 *             -Hvfile
 *              file format (" " incidate strings, not numerical values):
 *              1D/2D/3D:
 *               "h" x1 y1 nz z_1 v_1 ... z_nz v_nz
 *               "h" x1 y2 ... 
 *                ...
 *               "h" x_nx y1 ...
 *               ...
 *               "h" x_nx y_ny ...
 *               "end"
 *              
 *              nz can vary for each "h" line.
 *              Last velocity provided will be used if input model is not extensive enough.
 *              1D: 1 line. Keep x1 and y1 constant.
 *              2D: nx (or ny) lines. Keep y1 (or x1) constant. y-dimension (or x-) is generated by repeating the 2D model.
 *              3D: nx*ny lines. x1 and y1 are NOT exchangeable in vfile, FOLLOW FORMAT STRICTLY.
 *     [Zelt's v.in]
 *             -Cv.in/ilayer [ -Filayer/refl_file [ -d<dump> ]]
 *
 * <grid generation options>
 *     [uniform spacing grid]:
 *             -Nnx/ny/nz -Dxmax/ymax/zmax -Ttfile
 *     [variable spacing grid]:
 *             -Xxfile -Yyfile -Zzfile -Ttfile
 *     [Zelt-based grid]:
 *             -Edx -Zzfile 
 *
 * Adria Melendez and Jun Korenaga,
 * Summer 2011
 *
 * 2010.10.6: -H option added
 */

#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include "array.h"
#include "util3d.h"
#include "zeltform3d.h"

double intp_from_hungvel(double, int, int,
			 Array2d< Array1d<double> >&, 
			 Array2d< Array1d<double> >&);
const double eps=1e-10;
			 
int main(int argc, char **argv)
{
    bool getA=false, getB=false, getVelf=false, readZelt=false, getN=false;
    bool getD=false, getE=false, getXfn=false, getYfn=false, getZfn=false, getT=false;
    bool getWater=false, outRefl=false, err=false;
    bool zeltdump=false;
    double v0, vgrad, xmax, ymax, zmax, dx, wcol=0.0;
    int nx, ny, nz, ilayer, imoho;
    char *xfn, *yfn, *zfn, *tfn, *hfn, zeltfn[MaxStr], reflfn[MaxStr];
    char *zdfn; 
    double v_water = 1.50;
    double v_air = 0.330;
    
    for (int i=1; i<argc; i++){
	if (argv[i][0] == '-'){
	    switch(argv[i][1]){
	    case 'A':
		v0 = atof(&argv[i][2]);
		getA = true;
		break;
	    case 'B':
		vgrad = atof(&argv[i][2]);
		getB = true;
		break;
	    case 'H':
		hfn = &argv[i][2];
		getVelf = true;
		break;
	    case 'C':
		if (sscanf(&argv[i][2], "%[^/]/%d", (char*) &zeltfn, &ilayer) == 2){
		    readZelt = true;
		}else{
		    cerr << "invalid -C option\n";
		    err = true;
		}
		break;
	    case 'F':
		if (sscanf(&argv[i][2], "%d/%[^/]", &imoho, (char*) &reflfn) == 2){
		    outRefl = true;
		}else{
		    cerr << "invalid -F option\n";
		    err = true;
		}
		break;
	    case 'N':
		getN = true;
		if (sscanf(&argv[i][2], "%d/%d/%d", &nx, &ny, &nz) != 3){
		    cerr << "invalid -N option\n";
		}
		break;
	    case 'D':
		getD = true;
		if (sscanf(&argv[i][2], "%lf/%lf/%lf", &xmax, &ymax, &zmax) != 3){
		    cerr << "invalid -D option\n";
		}
		break;
	    case 'E':
		getE = true;
		dx = atof(&argv[i][2]);
		break;
	    case 'X':
		xfn = &argv[i][2];
		getXfn = true;
	    case 'Y':
		yfn = &argv[i][2];
		getYfn = true;
	    case 'Z':
		zfn = &argv[i][2];
		getZfn = true;
		break;
	    case 'd':
		zdfn = &argv[i][2];
		zeltdump = true;
		break;
	    case 'T':
		tfn = &argv[i][2];
		getT = true;
		break;
	    case 'W':
		getWater = true;
		wcol = atof(&argv[i][2]);
		break;
	    case 'Q':
		v_water = atof(&argv[i][2]);
		break;
	    case 'R':
		v_air = atof(&argv[i][2]);
		break;
	    default:
		err = true;
		break;
	    }
	}else{
	    err = true;
	}
    }

    int velopt=0, gridopt=0;
    bool uniGradient=false;
    bool uniGrid=false, varGrid=false;
    if (getA && getB){ uniGradient=true; velopt++; }
    if (getVelf){ velopt++; }
    if (readZelt){ velopt++; gridopt++; } 
    if (getN && getD){ uniGrid=true; gridopt++; }
    if (getXfn && getYfn && getZfn){ varGrid=true; gridopt++; }

    if (velopt!=1 || gridopt!=1){
	cerr << "too many (or too few) options!\n";
	err=true;
    }
    if (getT && !(varGrid || uniGrid)){
      cerr << "for -T, also use -X & -Z or -N & -D.\n";
      err=true;
    }
    if (readZelt && !(getZfn && getE)){
      cerr << "incomplete Zelt options.\n";
      err=true;
    }
    if (outRefl && !readZelt){
      cerr << "-C is required to use -F.\n";
      err = true;
    }
    if (err) error("usage: gen_smesh3d [ -options ]");

    Array1d<double> x, y, z, x_moho;
    Array2d<double> topo, moho;
    ZeltVelocityModel2d* pzelt;
    if (uniGrid){
      x.resize(nx); y.resize(ny); topo.resize(nx,ny); z.resize(nz);
      double dx = xmax/(nx-1);
      double dy = ymax/(ny-1);
      double dz = zmax/(nz-1);
      for (int i=1; i<=nx; i++) x(i) = (i-1)*dx;
      for (int i=1; i<=ny; i++) y(i) = (i-1)*dy;
      for (int i=1; i<=nz; i++) z(i) = (i-1)*dz;
      if (getT){
	//	int ntopo = countLines(tfn); //what format for tfile?
	ifstream tin(tfn);
	int ntopo=0;
	for (int i=1; i<=nx; i++){
	  for (int j=1; j<=ny; j++){
	    tin >> topo(i,j);
	    ntopo++;
	  }
	}
	if (ntopo != nx*ny){
	  error("gen_smesh3d::size mismatch for topo file");
	}
      }else{
	topo = 0.0;
      }
    }else if (varGrid){
      nx = countLines(xfn);
      ny = countLines(yfn);
      nz = countLines(zfn);
      x.resize(nx); y.resize(ny); z.resize(nz); topo.resize(nx,ny);
      ifstream xin(xfn), yin(yfn), zin(zfn), tin(tfn);
      for (int i=1; i<=nx; i++) xin >> x(i);
      for (int i=1; i<=ny; i++) yin >> y(i);
      for (int i=1; i<=nz; i++) zin >> z(i);
      if (getT){
	//	int ntopo = countLines(tfn); //what format for tfile?
	int ntopo=0;
	for (int i=1; i<=nx; i++){
	  for (int j=1; j<=ny; j++){
	    tin >> topo(i,j);
	    ntopo++;
	  }
	}
	if (ntopo != nx*ny){
	  error("gen_smesh3d::size mismatch for topo file");
	}
      }else{
	topo = 0.0;
      }
    }else if (readZelt){ // Not modified yet.
      nz = countLines(zfn);
      z.resize(nz);
      ifstream zin(zfn);
      for (int i=1; i<=nz; i++) zin >> z(i);
      pzelt = new ZeltVelocityModel2d(zeltfn);
      if (outRefl){
	//	pzelt->getTopo(imoho, dx, x_moho, moho); // Need to define getTopo(int,double,Array1d,Array2d) in zeltform3d.cc
      }
      //      pzelt->getTopo(ilayer, dx, x, topo);
      nx = x.size();
      if (zeltdump) pzelt->dumpNodes(zdfn);
    }

    int nxh, nyh;
    Array1d<double> vf_x(0), vf_y(0), vf_tmpz(0), vf_tmpv(0);
    Array1d<int> vf_nz(0);
    Array2d< Array1d<double> > vf_z, vf_v; // or Array1d< Array1d< Array1d<double> > >? Array3d?
    if (getVelf){
      string word;
      ifstream hin(hfn);
      double pxval=-1.0, pyval=-1.0;
      int count=0;
      do {
	hin >> word;
	double xval, yval;
	if (word == "h"){
	  hin >> xval >> yval;
//	  cerr<<"xval="<<xval<<" yval="<<yval<<'\n';
	  if(xval!=pxval){
	    vf_x.push_back(xval);
	    pxval=xval;
	    count++;
	  }
	  if(count==1 && yval!=pyval){
	    vf_y.push_back(yval);
	    pyval=yval;
	  }
//	  cerr<<"pxval="<<pxval<<" pyval="<<pyval<<'\n';
//	  cerr<<"vf_x="<<vf_x(vf_x.size())<<" vf_y="<<vf_y(vf_y.size())<<'\n';
	  int nzh;
	  double zval, vval;
	  hin >> nzh;
//	  cerr<<"nzh="<<nzh<<'\n';
	  if (nzh<2){
	    cerr << "error in " << hfn << ": nz must be >=2";
	    exit(1);
	  }
	  vf_nz.push_back(nzh);
//	  cerr<<"vf_nz="<<vf_nz(vf_nz.size())<<'\n';
	  for (int i=1; i<=nzh; i++){
	    hin >> zval >> vval;
//	    cerr<<"zval="<<zval<<" vval="<<vval<<'\n';
	    vf_tmpz.push_back(zval);
	    vf_tmpv.push_back(vval);
//	    cerr<<"vf_tmpz="<<vf_tmpz(i)<<" vf_tmpv="<<vf_tmpv(i)<<'\n';
	  }
	}
      } while(word != "end");

      nxh = vf_x.size();
      nyh = vf_y.size();
//      cerr<<"nxh="<<nxh<<" nyh="<<nyh<<'\n';
      vf_z.resize(nxh,nyh);
      vf_v.resize(nxh,nyh);
      int ii = 1;
      int jj = 1;
      for (int i=1; i<=nxh; i++){
	for (int j=1; j<=nyh; j++){
	  vf_z(i,j).resize(vf_nz(jj));
	  vf_v(i,j).resize(vf_nz(jj));
//	  cerr<<"vf_nz("<<jj<<")="<<vf_nz(jj)<<'\n';
	  for (int k=1; k<=vf_nz(jj); k++){
	    vf_z(i,j)(k) = vf_tmpz(ii);
	    vf_v(i,j)(k) = vf_tmpv(ii);
//	    cerr << "vf_z,v= " << vf_z(i,j)(k) << ", " << vf_v(i,j)(k) << '\n';
	    ii++;
	  }
	  jj++;
//	  cerr<<"nxh= "<<nxh<<" nyh="<<nyh<<'\n';
	}
      }
    }

    cout << nx << " " << ny << " " << nz << " " << v_water << " " << v_air << '\n';
    for (int i=1; i<=nx; i++)  cout << x(i) << " ";
    cout << '\n';
    for (int j=1; j<=ny; j++)  cout << y(j) << " ";
    cout << '\n';
    for (int i=1; i<=nx; i++){
      for(int j=1; j<=ny; j++){
	cout << topo(i,j) << " ";
      }
      cout << '\n';
    }
    for (int k=1; k<=nz; k++)  cout << z(k) << " ";
    cout << '\n';

    for (int i=1; i<=nx; i++){
      for(int j=1; j<=ny; j++){
	for (int k=1; k<=nz; k++){
	  double v;
	  if (getVelf){
	    if (nxh==1 && nyh==1){ // 1D profile 
//	      cerr<<"1D\n";
//	      cerr << "nxh=" << nxh << " nyh=" << nyh << '\n';
	      v = intp_from_hungvel(z(k),nxh,nyh,vf_z,vf_v);
//	      cerr << "v=" << v << '\n';
	    }else if (nxh==1 || nyh==1){ // 2D profile
//	      cerr<<"2D\n";
	      v = -1.0;
	      double v1, v2, ratio;
	      if(nxh>nyh){ //nyh is 1, y is not a real dimension.
		for (int ii=2; ii<=nxh; ii++){
		  if (x(i)>=vf_x(ii-1) && x(i)<vf_x(ii)){
		    v1 = intp_from_hungvel(z(k),ii-1,nyh,vf_z,vf_v);
		    v2 = intp_from_hungvel(z(k),ii,nyh,vf_z,vf_v);
		    ratio = (x(i)-vf_x(ii-1))/(vf_x(ii)-vf_x(ii-1));
		    v = v1*(1-ratio)+v2*ratio;
		    break;
		  }else if(ii==nxh && x(i)>=vf_x(ii)){
		    v = intp_from_hungvel(z(k),ii,nyh,vf_z,vf_v);
		  }
		}
	      }else{ //nxh is 1, x is not a real dimension.
		for (int ii=2; ii<=nyh; ii++){
		  if (y(j)>=vf_y(ii-1) && y(j)<vf_y(ii)){
		    v1 = intp_from_hungvel(z(k),nxh,ii-1,vf_z,vf_v);
		    v2 = intp_from_hungvel(z(k),nxh,ii,vf_z,vf_v);
		    ratio = (y(j)-vf_y(ii-1))/(vf_y(ii)-vf_y(ii-1));
		    v = v1*(1-ratio)+v2*ratio;
		    break;
		  }else if(ii==nyh && y(j)>=vf_y(ii)){
		    v = intp_from_hungvel(z(k),nxh,ii,vf_z,vf_v);
		  }
		}
	      }
	    }else{ // 3D profile
//	      cerr<<"3D\n";
	      double v1, v2, v3, v4, rx, ry;
	      for (int ii=2; ii<=nxh; ii++){
		if (x(i)>=vf_x(ii-1) && x(i)<vf_x(ii)){
		  for (int jj=2; jj<=nyh; jj++){
		    if (y(j)>=vf_y(jj-1) && y(j)<vf_y(jj)){
		      v1 = intp_from_hungvel(z(k),ii-1,jj-1,vf_z,vf_v);
		      v2 = intp_from_hungvel(z(k),ii,jj-1,vf_z,vf_v);
		      v3 = intp_from_hungvel(z(k),ii-1,jj,vf_z,vf_v);
		      v4 = intp_from_hungvel(z(k),ii,jj,vf_z,vf_v);
		      rx = (x(i)-vf_x(ii-1))/(vf_x(ii)-vf_x(ii-1));
		      ry = (y(j)-vf_y(jj-1))/(vf_y(jj)-vf_y(jj-1));
		      v = v1*(1-rx-ry-rx*ry)+v2*(rx-rx*ry)+v3*(ry-rx*ry)+v4*rx*ry;
		      break;
		    }else if(jj==nyh && y(j)>=vf_y(jj)){
		      v3 = intp_from_hungvel(z(k),ii-1,nyh,vf_z,vf_v);
		      v4 = intp_from_hungvel(z(k),ii,nyh,vf_z,vf_v);
		      rx = (x(i)-vf_x(ii-1))/(vf_x(ii)-vf_x(ii-1));
		      v = v3*(1-rx)+v4*rx;
		    }
		  }
		}else if(ii==nxh && x(i)>=vf_x(ii)){
		  for (int jj=2; jj<=nyh; jj++){
		    if (y(j)>=vf_y(jj-1) && y(j)<vf_y(jj)){
		      v1 = intp_from_hungvel(z(k),nxh,jj-1,vf_z,vf_v);
		      v2 = intp_from_hungvel(z(k),nxh,jj,vf_z,vf_v);
		      ry = (y(j)-vf_y(jj-1))/(vf_y(jj)-vf_y(jj-1));
		      v = v1*(1-ry)+v2*ry;
		      break;
		    }else if(jj==nyh && y(j)>=vf_y(jj)){
		      v = intp_from_hungvel(z(k),nxh,nyh,vf_z,vf_v);
		    }
		  }
		}
	      }
	    }
	    if (v<0){
	      cerr << "interpolation failed at x=" << x(i)
		   << ", y=" << y(j) << ", z=" << z(k) 
		   << "; check " << hfn << '\n';
	      exit(1);
	    }
	  }else if (readZelt){ // Modified to allow compilation of gen_smesh3d.cc
	    // note: this 'eps' is essential to stabilize
	    // interpolation used for Zelt model.
	    // (e.g., to skip null cells, to get subseafloor
	    //  velocity not seawater velocity for the surface velocity)
	    v = pzelt->at(x(i),y(j),topo(i,j)+z(k)+eps);
	  }else{
	    if (z(k) < wcol){
	      v = 1.5;
	    }else{
	      v = v0+vgrad*(z(k)-wcol);
	    }
	  }
	  cout << v << " ";
	}
	cout << '\n';
      }
    }
    if (outRefl){ // Modified to allow compilation of gen_smesh3d.cc
      ofstream os(reflfn);
      for (int i=1; i<=x_moho.size(); i++){
	for (int j=1; j<=x_moho.size(); j++){ // x_moho should be replaced by y_moho in these two lines.
	  os << x_moho(i) << " " << x_moho(j) << " " << moho(i,j) << '\n';
	}
      }
    }
}

double intp_from_hungvel(double z, int i, int j,
			 Array2d< Array1d<double> >& vf_z, 
			 Array2d< Array1d<double> >& vf_v)
{
//  cerr<<"z="<<z<<'\n';
//  cerr<<"vf_z("<<i<<","<<j<<")("<<1<<")="<<vf_z(i,j)(1)<<'\n';
  for (int k=2; k<=vf_z(i,j).size(); k++){
//    cerr<< "vf_z("<< i << "," << j << ")(" << k << ")=" << vf_z(i,j)(k) << "\n";
    if (z>=vf_z(i,j)(k-1) && z<vf_z(i,j)(k)){
      double ratio = (z-vf_z(i,j)(k-1))/(vf_z(i,j)(k)-vf_z(i,j)(k-1));
      return vf_v(i,j)(k-1)*(1-ratio)+vf_v(i,j)(k)*ratio;
    }else if (k==vf_z(i,j).size() && z>=vf_z(i,j)(k)){
      return vf_v(i,j)(k);
    }
  }
  return -1; // failure
}

